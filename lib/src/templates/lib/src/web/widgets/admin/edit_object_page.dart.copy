// ignore_for_file: depend_on_referenced_packages

import 'dart:convert';

import 'package:collection/collection.dart';
import 'package:demo_server/src/web/utils/admin/admin_utils.dart';
import 'package:recase/recase.dart';
import 'package:serverpod/serverpod.dart';

class EditObjectPage extends Widget {
  String resource;
  String? id;
  final Map<String, dynamic> object;
  final List<Map<String, dynamic>> storageFiles;
  final Map<String, List<Map<String, dynamic>>> relatedOptions;

  EditObjectPage({
    required this.resource,
    required this.id,
    required this.object,
    required this.storageFiles,
    this.relatedOptions = const {},
  }) : super(name: 'edit_object_page') {
    id = id.toString();
    resource = resource.toLowerCase();

    // add missing nullable field names to the json object
    final columns = modelsMap[resource]['columns'] as List<String>;
    for (var column in columns) {
      if (!object.containsKey(column)) {
        object[column] = null;
      }
    }

    final List<Map<String, dynamic>> objectFields = object.entries.where((entry) {
      final fieldName = entry.key;
      final isPrivateField = fieldName.startsWith('_');
      return !isPrivateField;
    }).map((entry) {
      final fieldName = entry.key;
      final fieldValue = entry.value;
      final fieldType = modelsMap[resource]['schema'][fieldName]!.toString();
      final nonNullableFieldType = fieldType.replaceAll('?', '');
      final isRequired = !fieldType.endsWith('?');

      return <String, dynamic>{
        "field_name": fieldName,
        "field_value": fieldValue,
        "field_type": nonNullableFieldType,
        "required": isRequired,
      };
    }).map((objectField) {
      final json = <String, dynamic>{}..addAll(objectField);

      final nonNullableFieldType = json['field_type'].toString().replaceAll('?', '');
      final relatedFieldsMap = (modelsMap[resource.toLowerCase()]['related_fields'] as Map<String, dynamic>);
      final isListType = json['field_type'].toString().startsWith('List');
      final isRelatedObject = relatedFieldsMap.containsKey(json['field_name']) && !isListType;

      final isRelatedObjectList = relatedFieldsMap.containsKey(json['field_name']) && isListType;

      // if field is a related field the nullability should be checked from the type specified for this field
      // in the related_fields section of the [modelsMap]
      if (isRelatedObject) {
        final relatedFieldType = relatedFieldsMap[json['field_name']].toString();
        json['required'] = !relatedFieldType.endsWith('?');
      }

      // checking if field is enum and add required variables to mustache payload
      final allEnumModels = modelsMap.entries.where((entry) {
        return entry.value['enum'] != null;
      });

      final enumModelForCurrentField = allEnumModels.firstElementWhereOrNull((entry) {
        final enumType = entry.value['enum'];
        return enumType == nonNullableFieldType;
      });

      final isEnum = enumModelForCurrentField != null;
      final enumOptions = enumModelForCurrentField?.value['values'] as List? ?? [];

      // extract the type of related object from field_type eg List<Person>? -> Person
      final regex = RegExp(
        r'(?:List|Set)<\s*([^>]+?)\s*>\s*\??|\bMap<\s*String\s*,\s*([^>]+?)\s*>\s*\??|^\s*([A-Za-z_]\w*(?:\.[A-Za-z_]\w*)*\??)\s*$',
      );

      final match = regex.firstMatch(json['field_type'].toString())!;
      final captured = (match.group(1) ?? match.group(2) ?? match.group(3))?.trim();
      final relatedObjectType = captured?.isEmpty == true ? null : captured;
      final String? relatedResource = (relatedObjectType == null) ? null : relatedObjectType.toString().toLowerCase();

      // Prepare selected ids for relations
      final String? relatedSelectedId = isRelatedObject ? ((json['field_value'] as Map?)?['id']?.toString()) : null;
      final List<String> relatedSelectedIds = isRelatedObjectList
          ? ((json['field_value'] as List?)?.map((e) => e['id']?.toString()).whereType<String>().toList() ?? <String>[])
          : <String>[];

      // Base options for this related type
      final List<Map<String, dynamic>> baseRelatedOptions = (relatedResource != null)
          ? (relatedOptions[relatedResource] ?? const <Map<String, dynamic>>[])
          : const <Map<String, dynamic>>[];

      // Single relation option list with selected markers
      final List<Map<String, dynamic>> singleRelatedOptions = baseRelatedOptions
          .map((o) => {
                ...o,
                'selected': relatedSelectedId != null && o['id']?.toString() == relatedSelectedId,
              })
          .toList();

      // Related list items: one select per selected id (or one empty if none selected)
      final List<Map<String, dynamic>> relatedListItems = isRelatedObjectList
          ? (relatedSelectedIds.isNotEmpty
              ? relatedSelectedIds
                  .map((sid) => {
                        'options': baseRelatedOptions
                            .map((o) => {
                                  ...o,
                                  'selected': o['id']?.toString() == sid,
                                })
                            .toList(),
                      })
                  .toList()
              : [
                  {
                    'options': baseRelatedOptions.map((o) => {...o, 'selected': false}).toList(),
                  }
                ])
          : const <Map<String, dynamic>>[];

      json.addAll({
        'error': null,
        'has_value': json['field_value'] != null,
        'bool': json['field_type'] == 'bool',
        'int': json['field_type'] == 'int',
        'double': json['field_type'] == 'double',
        'String': json['field_type'] == 'String',
        'Duration': json['field_type'] == 'Duration',
        'DateTime': json['field_type'] == 'DateTime',
        'ByteData': json['field_type'] == 'ByteData',
        'UuidValue': json['field_type'] == 'UuidValue',
        'Uri': json['field_type'] == 'Uri',
        'BigInt': json['field_type'] == 'BigInt',
        'Vector': json['field_type'] == 'Vector',

        // don't render generic list UI for related lists
        'is_list': json['field_type'].toString().startsWith('List') && !isRelatedObjectList,
        'is_set': json['field_type'].toString().startsWith('Set'),
        'is_map': json['field_type'].toString().startsWith('Map'),

        // list
        'is_list_string': json['field_type'].toString().startsWith('List<String>'),
        'is_list_int': json['field_type'].toString().startsWith('List<int>'),
        'is_list_double': json['field_type'].toString().startsWith('List<double>'),
        'is_list_num': json['field_type'].toString().startsWith('List<num>'),
        'is_list_bool': json['field_type'].toString().startsWith('List<bool>'),
        'is_list_uri': json['field_type'].toString().startsWith('List<Uri>'),

        // set
        'is_set_string': json['field_type'].toString().startsWith('Set<String>'),
        'is_set_int': json['field_type'].toString().startsWith('Set<int>'),
        'is_set_double': json['field_type'].toString().startsWith('Set<double>'),
        'is_set_num': json['field_type'].toString().startsWith('Set<num>'),
        'is_set_bool': json['field_type'].toString().startsWith('Set<bool>'),
        'is_set_uri': json['field_type'].toString().startsWith('Set<Uri>'),

        // map
        'is_map_string_string': json['field_type'].toString().startsWith('Map<String, String>'),
        'is_map_string_int': json['field_type'].toString().startsWith('Map<String, int>'),
        'is_map_string_double': json['field_type'].toString().startsWith('Map<String, double>'),
        'is_map_string_num': json['field_type'].toString().startsWith('Map<String, num>'),
        'is_map_string_bool': json['field_type'].toString().startsWith('Map<String, bool>'),
        'is_map_string_uri': json['field_type'].toString().startsWith('Map<String, Uri>'),

        'is_enum': isEnum,
        if (isEnum) 'enum_options': enumOptions,

        'is_related_object': isRelatedObject,
        'is_related_object_list': isRelatedObjectList,
        'related_object_type': relatedObjectType,
        if (isRelatedObject) 'related_selected_id': relatedSelectedId,
        if (isRelatedObjectList) 'related_selected_ids': relatedSelectedIds,
        // options for this specific related field
        if (isRelatedObject) 'related_options': singleRelatedOptions,
        if (isRelatedObjectList) 'related_list_items': relatedListItems,

        // since mustache cannot iterate maps like it does for lists, a simplified list of map entries is added.
        'map_entries': json['field_type'].toString().startsWith('Map') && json['field_value'] != null
            ? (json['field_value'] as Map<String, dynamic>).entries.map((entry) {
                return <String, dynamic>{'key': entry.key, 'value': entry.value};
              }).toList()
            : null,

        // for mustache simple processing of lists, sets
        'list_items':
            (json['field_type'].toString().startsWith('List') || json['field_type'].toString().startsWith('Set')) &&
                    json['field_value'] != null
                ? (json['field_value'] as List).mapIndexed((index, item) => {
                      'list_item': item,
                      'list_item_index': index,
                    })
                : null,
      });

      return json;
    }).toList();

    values = {
      "id": id,
      "table_url": "/admin/list/$resource",
      "view_url": "/admin/view/$resource/$id",
      "save_url": "/admin/save/$resource/$id",
      "delete_url": "/admin/delete/$resource/$id",
      "class": resource.pascalCase,
      "object_fields": objectFields,
      "storage_files": storageFiles,
      // expose for JS add item helper
      "related_options_json": jsonEncode(relatedOptions),
    };
  }
}
