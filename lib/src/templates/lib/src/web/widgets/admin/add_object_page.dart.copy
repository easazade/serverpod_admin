import 'dart:convert';

import 'package:demo_server/src/web/utils/admin/admin_utils.dart';
import 'package:recase/recase.dart';
import 'package:serverpod/serverpod.dart';

class AddObjectPage extends Widget {
  String resource;
  final List<Map<String, dynamic>> storageFiles;
  final Map<String, List<Map<String, dynamic>>> relatedOptions;

  AddObjectPage({
    required this.resource,
    required this.storageFiles,
    this.relatedOptions = const {},
  }) : super(name: 'add_object_page') {
    resource = resource.toLowerCase();
    // Generate object fields similar to ViewObjectPage
    final Map<String, dynamic> schema = (modelsMap[resource]['schema'] as Map<String, dynamic>).copyMap();
    final Map<String, dynamic> relatedFieldsMap = (modelsMap[resource]['related_fields'] as Map<String, dynamic>);

    // remove foreign keys if there is already a related object
    // field for that foreign key to assign value to in add_object_page.html
    for (var relatedField in relatedFieldsMap.entries) {
      final name = relatedField.key;
      final foreignKeyName = '${name}Id';
      schema.removeWhere((fieldName, type) => fieldName == foreignKeyName);
    }

    final List<Map<String, dynamic>> objectFields = schema.entries.map((entry) {
      final fieldName = entry.key;
      final fieldType = entry.value.toString();
      print(fieldType);
      final nonNullableFieldType = fieldType.replaceAll('?', '');
      print(nonNullableFieldType);
      var isRequired = !fieldType.endsWith('?');

      // Detect related field metadata
      final bool isListType = nonNullableFieldType.startsWith('List');
      final bool isRelatedObject = relatedFieldsMap.containsKey(fieldName) && !isListType;
      final bool isRelatedObjectList = relatedFieldsMap.containsKey(fieldName) && isListType;

      // if field is a related field the nullability should be checked from the type specified for this field in the related_fields section of the [modelsMap] 
      if (isRelatedObject) {
        final relatedFieldType = relatedFieldsMap[fieldName].toString();
        isRequired = !relatedFieldType.endsWith('?');
      }

      // Extract related object type from field type
      final regex = RegExp(
        r'(?:List|Set)<\s*([^>]+?)\s*>\s*\??|\bMap<\s*String\s*,\s*([^>]+?)\s*>\s*\??|^\s*([A-Za-z_]\w*(?:\.[A-Za-z_]\w*)*\??)\s*$',
      );
      final match = regex.firstMatch(nonNullableFieldType);
      final captured = (match?.group(1) ?? match?.group(2) ?? match?.group(3))?.trim();
      final String? relatedObjectType = (captured == null || captured.isEmpty) ? null : captured;
      final String? relatedResource = (relatedObjectType == null) ? null : relatedObjectType.toLowerCase();

      // Base options for this related type
      final List<Map<String, dynamic>> baseRelatedOptions = (relatedResource != null)
          ? (relatedOptions[relatedResource] ?? const <Map<String, dynamic>>[])
          : const <Map<String, dynamic>>[];

      // Single relation options without selection
      final List<Map<String, dynamic>> singleRelatedOptions = baseRelatedOptions
          .map((o) => {
                ...o,
                'selected': false,
              })
          .toList();

      // Related list items: start with one empty select
      final List<Map<String, dynamic>> relatedListItems = isRelatedObjectList
          ? [
              {
                'options': baseRelatedOptions
                    .map((o) => {
                          ...o,
                          'selected': false,
                        })
                    .toList(),
              }
            ]
          : const <Map<String, dynamic>>[];

      final fieldJson = <String, dynamic>{
        "field_name": fieldName,
        "field_type": nonNullableFieldType,
        "required": isRequired,
        'is_related_object': isRelatedObject,
        'is_related_object_list': isRelatedObjectList,
        'related_object_type': relatedObjectType,
        if (isRelatedObject) 'related_options': singleRelatedOptions,
        if (isRelatedObjectList) 'related_list_items': relatedListItems,
      };

      return fieldJson;
    }).map((objectField) {
      final json = <String, dynamic>{}..addAll(objectField);

      json.addAll({
        'error': null,
        'bool': json['field_type'] == 'bool',
        'int': json['field_type'] == 'int',
        'double': json['field_type'] == 'double',
        'String': json['field_type'] == 'String',
        'Duration': json['field_type'] == 'Duration',
        'DateTime': json['field_type'] == 'DateTime',
        'ByteData': json['field_type'] == 'ByteData',
        'UuidValue': json['field_type'] == 'UuidValue',
        'Uri': json['field_type'] == 'Uri',
        'BigInt': json['field_type'] == 'BigInt',
        'Vector': json['field_type'] == 'Vector',

        // Don't render generic list UI for related lists
        'is_list': json['field_type'].toString().startsWith('List') && (json['is_related_object_list'] != true),
        'is_map': json['field_type'].toString().startsWith('Map'),
        'is_set': json['field_type'].toString().startsWith('Set'),

        // list
        'is_list_string': json['field_type'].toString().startsWith('List<String>'),
        'is_list_int': json['field_type'].toString().startsWith('List<int>'),
        'is_list_double': json['field_type'].toString().startsWith('List<double>'),
        'is_list_num': json['field_type'].toString().startsWith('List<num>'),
        'is_list_bool': json['field_type'].toString().startsWith('List<bool>'),
        'is_list_uri': json['field_type'].toString().startsWith('List<Uri>'),

        // set
        'is_set_string': json['field_type'].toString().startsWith('Set<String>'),
        'is_set_int': json['field_type'].toString().startsWith('Set<int>'),
        'is_set_double': json['field_type'].toString().startsWith('Set<double>'),
        'is_set_num': json['field_type'].toString().startsWith('Set<num>'),
        'is_set_bool': json['field_type'].toString().startsWith('Set<bool>'),
        'is_set_uri': json['field_type'].toString().startsWith('Set<Uri>'),

        // map
        'is_map_string_string': json['field_type'].toString().startsWith('Map<String, String>'),
        'is_map_string_int': json['field_type'].toString().startsWith('Map<String, int>'),
        'is_map_string_double': json['field_type'].toString().startsWith('Map<String, double>'),
        'is_map_string_num': json['field_type'].toString().startsWith('Map<String, num>'),
        'is_map_string_bool': json['field_type'].toString().startsWith('Map<String, bool>'),
        'is_map_string_uri': json['field_type'].toString().startsWith('Map<String, Uri>'),
      });

      return json;
    }).toList();

    values = {
      "table_url": "/admin/list/$resource",
      "save_url": "/admin/save/$resource",
      "class": resource.pascalCase,
      "resource": resource,
      "object_fields": objectFields,
      "storage_files": storageFiles,
      // expose for JS add item helper
      "related_options_json": jsonEncode(relatedOptions),
    };
  }
}
